#include <string.h>
#include "config.h"

static config_t config;


/*
	Default Resistance Thresholds (Ohms)
	Measured Resistance must be > threshold to PASS
*/
const float P1V2_R_THRESHOLD_DEFAULT 	= 10000;
const float P1V8_R_THRESHOLD_DEFAULT 	= 10000;
const float P3V3A_R_THRESHOLD_DEFAULT 	= 10000;
const float P3V3IO_R_THRESHOLD_DEFAULT 	= 10000;
const float P5V_R_THRESHOLD_DEFAULT 	= 10000;
const float P10V_R_THRESHOLD_DEFAULT 	= 10000;
const float PVMAIN_R_THRESHOLD_DEFAULT 	= 10000;
const float SWD_R_THRESHOLD_DEFAULT 	= 100000;
const float CAN_R_THRESHOLD_DEFAULT 	= 100000;


/*
	Default Voltage Expected Values and Tolerances (Volts)
	Measured Voltage must be within expected +/- tolerance to PASS
*/
const float P1V2_V_EXPECTED_DEFAULT 	= 1.2;
const float P1V8_V_EXPECTED_DEFAULT 	= 1.8;
const float P3V3A_V_EXPECTED_DEFAULT 	= 3.3;
const float P3V3IO_V_EXPECTED_DEFAULT 	= 3.3;
const float P5V_V_EXPECTED_DEFAULT 		= 5;
const float P10V_V_EXPECTED_DEFAULT 	= 10;
const float PVMAIN_V_EXPECTED_DEFAULT 	= 36;

const float P1V2_V_TOLERANCE_DEFAULT 	= 0.1;
const float P1V8_V_TOLERANCE_DEFAULT 	= 0.1;
const float P3V3A_V_TOLERANCE_DEFAULT 	= 0.1;
const float P3V3IO_V_TOLERANCE_DEFAULT 	= 0.1;
const float P5V_V_TOLERANCE_DEFAULT 	= 0.1;
const float P10V_V_TOLERANCE_DEFAULT 	= 0.1;
const float PVMAIN_V_TOLERANCE_DEFAULT 	= 0.1;

/*
	Net Name to Default Config Mappings
*/
config_resistance_thresholds_t res_thresholds[] = {
    {.name = "P1V2", .threshold = P1V2_R_THRESHOLD_DEFAULT},
    {.name = "P1V8", .threshold = P1V8_R_THRESHOLD_DEFAULT},
    {.name = "P3V3_A", .threshold = P3V3A_R_THRESHOLD_DEFAULT},
    {.name = "P3V3_IO", .threshold = P3V3IO_R_THRESHOLD_DEFAULT},
    {.name = "P5V", .threshold = P5V_R_THRESHOLD_DEFAULT},
    {.name = "P10V", .threshold = P10V_R_THRESHOLD_DEFAULT},
    {.name = "PVMAIN", .threshold = PVMAIN_R_THRESHOLD_DEFAULT},
    {.name = "SWD", .threshold = SWD_R_THRESHOLD_DEFAULT},
    {.name = "CAN", .threshold = CAN_R_THRESHOLD_DEFAULT}
};

config_voltage_tolerances_t voltage_tolerances[] = {
    {.name = "P1V2", .expected = P1V2_V_EXPECTED_DEFAULT, .tolerance = P1V2_V_TOLERANCE_DEFAULT},
    {.name = "P1V8", .expected = P1V8_V_EXPECTED_DEFAULT, .tolerance = P1V8_V_TOLERANCE_DEFAULT},
    {.name = "P3V3_A", .expected = P3V3A_V_EXPECTED_DEFAULT, .tolerance = P3V3A_V_TOLERANCE_DEFAULT},
    {.name = "P3V3_IO", .expected = P3V3IO_V_EXPECTED_DEFAULT, .tolerance = P3V3IO_V_TOLERANCE_DEFAULT},
    {.name = "P5V", .expected = P5V_V_EXPECTED_DEFAULT, .tolerance = P5V_V_TOLERANCE_DEFAULT},
    {.name = "P10V", .expected = P10V_V_EXPECTED_DEFAULT, .tolerance = P10V_V_TOLERANCE_DEFAULT},
    {.name = "PVMAIN", .expected = PVMAIN_V_EXPECTED_DEFAULT, .tolerance = PVMAIN_V_TOLERANCE_DEFAULT}
};


static adc_result_t config_evaluate_resistance_threshold(float measurement, float threshold);
static adc_result_t config_evaluate_voltage_tolerance(float measurement, float expected, float tolerance);

// Public

/*
	Initializes config with default thresholds and tolerances
	@return Pointer to initialized config_t struct
*/
config_t* config_init() {
	memcpy(config.resistance_thresholds, res_thresholds, sizeof(res_thresholds));
	memcpy(config.voltage_tolerances, voltage_tolerances, sizeof(voltage_tolerances));
	return &config;
}


/*
	Evaluates resistance measurements against configured thresholds
	@param measurements: Pointer to array of adc_measurement_t structs with resistance measurements
	@return boolean did_any_fail: true if any measurement failed, false if all passed
	@note: Modifies measurements array to convert raw voltage measurements to resistance values based on voltage divider configuration
*/
bool config_evaluate_resistances(adc_measurement_t* measurements) {
	for (int i = 0; i < NUM_RESISTANCE_CHANNELS; i++) {
		if (strcmp(measurements[i].name, "SWD") == 0 || strcmp(measurements[i].name, "CAN") == 0) {
			float gain = measurements[i].measurement / 1.2f;
			measurements[i].measurement = 100000.0f * (gain / (1.0f - gain));
		} else {
			float gain = measurements[i].measurement / 1.2f;
			measurements[i].measurement = 10000.0f * (gain / (1.0f - gain));
		}
	}

	uint32_t results = 0;
	for (int i = 0; i < NUM_RESISTANCE_CHANNELS; i++) {
		measurements[i].result = config_evaluate_resistance_threshold(measurements[i].measurement, config.resistance_thresholds[i].threshold);
		results |= (measurements[i].result << i);
	}

	return results;
}
	

/*
	Evaluates voltage measurements against configured expected values and tolerances
	@param measurements: Pointer to array of adc_measurement_t structs with voltage measurements
	@return boolean did_any_fail: true if any measurement failed, false if all passed
*/
bool config_evaluate_voltages(adc_measurement_t* measurements) {
	uint32_t results = 0;
	for (int i = 0; i < NUM_VOLTAGE_CHANNELS; i++) {
		measurements[i].result = config_evaluate_voltage_tolerance(measurements[i].measurement, config.voltage_tolerances[i].expected, config.voltage_tolerances[i].tolerance);
		results |= (measurements[i].result << i);
	}

	return results;
}

// Private

/*
	Measured Resistance must be > threshold to PASS
	@param measurement: Measured resistance value
	@param threshold: Configured resistance threshold
	@return adc_result_t: PASS or FAIL
*/
static adc_result_t config_evaluate_resistance_threshold(float measurement, float threshold) {
	if (measurement >= threshold) {
		return PASS;
	} else {
		return FAIL;
	}
}

/*
	Measured Voltage must be within expected +/- tolerance to PASS
	@param measurement: Measured voltage value
	@param expected: Configured expected voltage value
	@param tolerance: Configured voltage tolerance
	@return adc_result_t: PASS or FAIL
*/
static adc_result_t config_evaluate_voltage_tolerance(float measurement, float expected, float tolerance) {
	if (measurement >= (expected - tolerance) && measurement <= (expected + tolerance)) {
		return PASS;
	} else {
		return FAIL;
	}
}

