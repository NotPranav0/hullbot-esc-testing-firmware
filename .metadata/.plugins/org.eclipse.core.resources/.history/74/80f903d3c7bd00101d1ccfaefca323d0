/**
 ******************************************************************************
 * @file    nhd_serial_lcd_i2c.c
 * @author  Gemini AI (based on Newhaven Display Arduino code)
 * @brief   Source file for NHD Serial LCD I2C driver for STM32 HAL.
 *
 * This driver is adapted from the Newhaven Display Arduino sample code
 * (Serial_LCD.ino) and targets the I2C interface using STM32 HAL functions.
 ******************************************************************************
 */

#include "nhd_serial_lcd_i2c.h"
#include "string.h" // For strlen

/**
 * @brief Initialize the LCD display.
 */
HAL_StatusTypeDef NHD_LCD_Init(NHD_LCD_I2C_HandleTypedef* h_lcd, I2C_HandleTypeDef* hi2c, uint8_t slave_addr_7bit)
{
    // Store configuration in the handle
    h_lcd->hi2c = hi2c;
    h_lcd->slave_addr_7bit = slave_addr_7bit;

    // Wait for display to power ON, as in original code
    HAL_Delay(NHD_STARTUP_DELAY);

    // Clear the screen on init
    return NHD_LCD_ClearScreen(h_lcd);
}

/**
 * @brief Write a single data byte to the display.
 * @note  The original Arduino driver sends one byte per I2C transaction
 * (START -> ADDR -> DATA -> STOP). We replicate that here.
 */
HAL_StatusTypeDef NHD_LCD_Write(NHD_LCD_I2C_HandleTypedef* h_lcd, uint8_t data)
{
    HAL_StatusTypeDef status;
    uint8_t pData[1];
    pData[0] = data;

    // The HAL function expects the 7-bit address left-shifted by 1
    uint16_t dev_addr = (h_lcd->slave_addr_7bit) << 1;

    // Transmit 1 byte of data
    status = HAL_I2C_Master_Transmit(h_lcd->hi2c, dev_addr, pData, 1, NHD_I2C_TIMEOUT);

    // The original code has a 150us delay after every write.
    // HAL_Delay(1) is the simplest equivalent (1ms).
    // If 1ms is too long, you must implement a microsecond delay
    // (e.g., using a DWT counter or a timer).
    HAL_Delay(1);

    return status;
}

/**
 * @brief Write a null-terminated string to the display.
 */
HAL_StatusTypeDef NHD_LCD_WriteString(NHD_LCD_I2C_HandleTypedef* h_lcd, char* str)
{
    HAL_StatusTypeDef status = HAL_OK;

    // Iterate through data until null terminator is found.
    while (*str != '\0')
    {
        status = NHD_LCD_Write(h_lcd, (uint8_t)*str);
        if (status != HAL_OK)
        {
            // Stop on I2C error
            return status;
        }
        str++; // Increment pointer.
    }

    return status;
}

/**
 * @brief Send the command prefix byte (0xFE).
 */
HAL_StatusTypeDef NHD_LCD_Prefix(NHD_LCD_I2C_HandleTypedef* h_lcd)
{
    return NHD_LCD_Write(h_lcd, 0xFE);
}

/**
 * @brief Turn the display ON.
 */
HAL_StatusTypeDef NHD_LCD_DisplayON(NHD_LCD_I2C_HandleTypedef* h_lcd)
{
    HAL_StatusTypeDef status = NHD_LCD_Prefix(h_lcd);
    if (status != HAL_OK) return status;
    return NHD_LCD_Write(h_lcd, 0x41);
}

/**
 * @brief Turn the display OFF.
 */
HAL_StatusTypeDef NHD_LCD_DisplayOFF(NHD_LCD_I2C_HandleTypedef* h_lcd)
{
    HAL_StatusTypeDef status = NHD_LCD_Prefix(h_lcd);
    if (status != HAL_OK) return status;
    return NHD_LCD_Write(h_lcd, 0x42);
}

/**
 * @brief Set the display cursor position via DDRAM address.
 */
HAL_StatusTypeDef NHD_LCD_SetCursor(NHD_LCD_I2C_HandleTypedef* h_lcd, uint8_t position)
{
    HAL_StatusTypeDef status = NHD_LCD_Prefix(h_lcd);
    if (status != HAL_OK) return status;
    return NHD_LCD_Write(h_lcd, 0x45);
}

/**
 * @brief Move the cursor to line 1, column 1.
 */
HAL_StatusTypeDef NHD_LCD_Home(NHD_LCD_I2C_HandleTypedef* h_lcd)
{
    HAL_StatusTypeDef status = NHD_LCD_Prefix(h_lcd);
    if (status != HAL_OK) return status;
    return NHD_LCD_Write(h_lcd, 0x46);
}

/**
 * @brief Clear the display screen.
 */
HAL_StatusTypeDef NHD_LCD_ClearScreen(NHD_LCD_I2C_HandleTypedef* h_lcd)
{
    HAL_StatusTypeDef status = NHD_LCD_Prefix(h_lcd);
    if (status != HAL_OK) return status;

    status = NHD_LCD_Write(h_lcd, 0x51);

    // Add 2ms delay as in original code
    HAL_Delay(2);

    return status;
}

/**
 * @brief Set the display's contrast.
 */
HAL_StatusTypeDef NHD_LCD_SetContrast(NHD_LCD_I2C_HandleTypedef* h_lcd, uint8_t contrast)
{
    HAL_StatusTypeDef status = NHD_LCD_Prefix(h_lcd);
    if (status != HAL_OK) return status;

    status = NHD_LCD_Write(h_lcd, 0x52);
    if (status != HAL_OK) return status;

    return NHD_LCD_Write(h_lcd, contrast);
}

/**
 * @brief Set the display's brightness.
 */
HAL_StatusTypeDef NHD_LCD_SetBrightness(NHD_LCD_I2C_HandleTypedef* h_lcd, uint8_t brightness)
{
    HAL_StatusTypeDef status = NHD_LCD_Prefix(h_lcd);
    if (status != HAL_OK) return status;

    status = NHD_LCD_Write(h_lcd, 0x53);
    if (status != HAL_OK) return status;

    return NHD_LCD_Write(h_lcd, brightness);
}

/**
 * @brief Turn the underline cursor ON.
 */
HAL_StatusTypeDef NHD_LCD_UnderlineCursorON(NHD_LCD_I2C_HandleTypedef* h_lcd)
{
    HAL_StatusTypeDef status = NHD_LCD_Prefix(h_lcd);
    if (status != HAL_OK) return status;
    return NHD_LCD_Write(h_lcd, 0x47);
}
