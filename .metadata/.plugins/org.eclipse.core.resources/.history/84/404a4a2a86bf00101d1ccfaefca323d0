#include <string.h>

#include "app.h"
#include "adc.h"
#include "button.h"
#include "esc.h"
#include "rpi_spi_link.h"
#include "lcd.h"
#include "config.h"

#include "stm32l4xx_hal.h"

#define WAIT_FOR_START_BUTTON

static ADC_HandleTypeDef* h_adc;
static CAN_HandleTypeDef* h_can;
static SPI_HandleTypeDef* h_spi;
static I2C_HandleTypeDef* h_i2c;

static config_t* h_config;

static bool pending_spi_packet = false;

static bool rpi_connection_attempted = false;

void app_main();
bool establish_rpi_connection();
void wait_for_esc_insert();
void resistance_tests();
void voltage_tests();

void test_main() {
	while (1) {
		resistance_tests();
		HAL_GPIO_TogglePin(USER_LED_GPIO_Port, USER_LED_Pin);
		HAL_Delay(1000);
	}
	
}

void app_init(ADC_HandleTypeDef* adc, CAN_HandleTypeDef* can, SPI_HandleTypeDef* spi, I2C_HandleTypeDef* i2c) {
	h_adc = adc;
	h_can = can;
	h_spi = spi;
	h_i2c = i2c;

	h_config = config_init();
	link_init(spi, &pending_spi_packet, h_config);
	adc_init(adc);
	lcd_init(i2c);
	esc_set_pwr(FLOATING);
	adc_set_1v2_source(FLOATING);

	test_main();

	app_main();

}

void app_main(void) {
	if (!rpi_connection_attempted) {
		establish_rpi_connection();
		rpi_connection_attempted = true;
		HAL_Delay(700);
	}
	
	wait_for_esc_insert();

	lcd_printf(LCD_LINE_1, "Press to Start");
	Press_Type_t press_type = PRESS_TYPE_NONE;

	while(press_type == PRESS_TYPE_NONE) {
		press_type = wait_on_button(HAL_MAX_DELAY);
	}

	if (press_type == PRESS_TYPE_SHORT) {
		lcd_clear_screen();
		lcd_printf(LCD_LINE_1, "Running Tests");
		resistance_tests();
	} else if (press_type == PRESS_TYPE_LONG) {
		rpi_press_power_button();
	}
}

bool establish_rpi_connection() {
	lcd_clear_screen();
	lcd_printf(LCD_LINE_1, "Waiting for RPI");
	lcd_printf(LCD_LINE_2, "Press to Skip");

	Press_Type_t press_type = PRESS_TYPE_NONE;

	while(press_type == PRESS_TYPE_NONE) {
		press_type = wait_on_button(500);
		if (rpi_is_awake()) {
			lcd_clear_screen();
			lcd_printf(LCD_LINE_1, "RPI Connected");
			return true;
		}
	}

	lcd_clear_screen();
	lcd_printf(LCD_LINE_1, "RPI Connection");
	lcd_printf(LCD_LINE_2, "Skipped");
	return false;
}

void wait_for_esc_insert() {
	if (!esc_is_connected()) {
		lcd_printf(LCD_LINE_1, "Insert ESC");

		while (!esc_is_connected()) {
			HAL_Delay(1);
		}
	}
	lcd_clear_screen();
}


void resistance_tests() {
	esc_set_pwr(FLOATING);
	esc_set_all_nets_mode(MEASUREMENT);
	adc_set_1v2_source(CONNECTED);


	adc_measurement_t measurements[NUM_RESISTANCE_CHANNELS] = {0};
	adc_take_measurements(measurements, RESISTANCE);
	bool any_failures = config_evaluate_resistances(measurements);
	rpi_send_debug_info((uint8_t*)measurements, sizeof(measurements));
	if (any_failures) {
		lcd_clear_screen();
		lcd_printf(LCD_LINE_1, "Short Detected");
		lcd_print_failed_nets(measurements, NUM_RESISTANCE_CHANNELS);
		while (esc_is_connected()) {
			HAL_Delay(1);
		}
		app_main(); // Restart the process
	} else {
		voltage_tests();
	}
}


void voltage_tests() {
	adc_set_1v2_source(FLOATING);
	esc_set_all_nets_mode(ORIGINAL);
	esc_set_pwr(CONNECTED);


	adc_measurement_t measurements[NUM_VOLTAGE_CHANNELS] = {0};
	adc_take_measurements(measurements, VOLTAGE);
	bool any_failures = config_evaluate_voltages(measurements);
	rpi_send_debug_info((uint8_t*)measurements, sizeof(measurements));
	if (any_failures) {
		lcd_clear_screen();
		lcd_printf(LCD_LINE_1, "Voltage Fault");
		lcd_print_failed_nets(measurements, NUM_VOLTAGE_CHANNELS);
	} else {
		lcd_clear_screen();
		lcd_printf(LCD_LINE_1, "All Tests Pass");
		lcd_printf(LCD_LINE_2, "Remove ESC");
	}
	while (esc_is_connected()) {
		HAL_Delay(1);
	}
	app_main(); // Restart the process

}

void lcd_print_failed_nets(adc_measurement_t* measurements, int num_measurements) {
	char failed_nets_buf[64];
	failed_nets_buf[0] = '\0';
	for (int i = 0; i < num_measurements; i++) {
		if (measurements[i].result == FAIL) {
			if (failed_nets_buf[0] != '\0') {
				strcat(failed_nets_buf, ",");
			}
			strcat(failed_nets_buf, measurements[i].name);
		}
	}
	lcd_printf(LCD_LINE_2, "%s", failed_nets_buf);
}
