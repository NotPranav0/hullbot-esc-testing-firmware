#include <string.h>

#include "app.h"
#include "adc.h"
#include "button.h"
#include "esc.h"
#include "rpi_spi_link.h"
#include "lcd.h"
#include "config.h"
#include "tinymovr.h"

#include "stm32l4xx_hal.h"

#define TESTING

static ADC_HandleTypeDef* h_adc;
static CAN_HandleTypeDef* h_can;
static SPI_HandleTypeDef* h_spi;
static I2C_HandleTypeDef* h_i2c;

static config_t* h_config;

static bool pending_spi_packet = false;

void app_main();
bool establish_rpi_connection();
void wait_for_esc_insert();
void resistance_tests();
void voltage_tests();
void lcd_print_failed_nets(adc_measurement_t* measurements, int num_measurements);
void debug_lcd_print_measurements(adc_measurement_t* measurements);

/*
	Test main replaaces app_main for debugging purposes
 */
void test_main() {
	while(1) {
		lcd_clear_screen();
		uint8_t can_id = tm_get_can_id();
		lcd_printf(LCD_LINE_1, "CAN ID: 0x%02X", can_id);
		HAL_Delay(2000);
	}
}

/*
	Initialize application
 */
void app_init(ADC_HandleTypeDef* adc, CAN_HandleTypeDef* can, SPI_HandleTypeDef* spi, I2C_HandleTypeDef* i2c) {
	h_adc = adc;
	h_can = can;
	h_spi = spi;
	h_i2c = i2c;

	h_config = config_init();
	link_init(spi, &pending_spi_packet, h_config);
	adc_init(adc);
	lcd_init(i2c);
	tm_init(can);

	esc_set_pwr(FLOATING);
	adc_set_1v2_source(FLOATING);

#ifdef TESTING
	test_main();
#else
	app_main();
#endif

}

void app_main(void) {
	establish_rpi_connection();
	
	while(1) {
		wait_for_esc_insert();

		lcd_printf(LCD_LINE_1, "Press to Start");
		Press_Type_t press_type = PRESS_TYPE_NONE;

		while(press_type == PRESS_TYPE_NONE) {
			press_type = wait_on_button(500);
			if (!esc_is_connected()) {
				break;
			}
		}

		if (!esc_is_connected()) {
			continue;
		}

		if (press_type == PRESS_TYPE_SHORT) {
			lcd_clear_screen();
			lcd_printf(LCD_LINE_1, "Running Tests");
			resistance_tests();
		} else if (press_type == PRESS_TYPE_LONG) {
			lcd_printf(LCD_LINE_1, "RPI Powered Off");
			rpi_press_power_button();
		}

		lcd_clear_screen();
	}
}

/*
	Establish connection with RPI, or skip if button pressed
 */
bool establish_rpi_connection() {
	lcd_clear_screen();
	lcd_printf(LCD_LINE_1, "Waiting for RPI");
	lcd_printf(LCD_LINE_2, "Press to Skip");

	Press_Type_t press_type = PRESS_TYPE_NONE;

	while(press_type == PRESS_TYPE_NONE) {
		press_type = wait_on_button(500);
		if (rpi_is_awake()) {
			lcd_clear_screen();
			lcd_printf(LCD_LINE_1, "RPI Connected");
			return true;
		}
	}

	lcd_clear_screen();
	lcd_printf(LCD_LINE_1, "RPI Connection");
	lcd_printf(LCD_LINE_2, "Skipped");
	HAL_Delay(1500);
	lcd_clear_screen();
	return false;
}

/*
	Wait for ESC to be inserted (blocking)
 */
void wait_for_esc_insert() {
	if (!esc_is_connected()) {
		lcd_clear_screen();
		lcd_printf(LCD_LINE_1, "Insert ESC");

		while (!esc_is_connected()) {
			HAL_Delay(1);
		}
	}
	lcd_clear_screen();
}

/*
	Run resistance tests
	1. Set ESC to measurement mode
	2. Take resistance measurements
	3. Evaluate results
	4. If any failures, display on LCD and wait for ESC removal
	5. If all pass, proceed to voltage tests
 */
void resistance_tests() {
	esc_set_pwr(FLOATING);
	esc_set_all_nets_mode(MEASUREMENT);
	adc_set_1v2_source(CONNECTED);


	adc_measurement_t measurements[NUM_RESISTANCE_CHANNELS] = {0};
	adc_take_measurements(measurements, RESISTANCE);
	bool any_failures = config_evaluate_resistances(measurements);
	
	rpi_send_debug_info((uint8_t*)measurements, sizeof(measurements));
	if (any_failures) {
		lcd_clear_screen();
		lcd_printf(LCD_LINE_1, "Short Detected");
		lcd_print_failed_nets(measurements, NUM_RESISTANCE_CHANNELS);
		while (esc_is_connected()) {
			lcd_print_failed_nets(measurements, NUM_RESISTANCE_CHANNELS);
			HAL_Delay(1);
		}
		return;
	} else {
		voltage_tests();
	}
}

/*
	Run voltage tests
	1. Set ESC to original mode
	2. Take voltage measurements
	3. Evaluate results
	4. If any failures, display on LCD and wait for ESC removal
	5. If all pass, display success message and wait for ESC removal
 */
void voltage_tests() {
	adc_set_1v2_source(FLOATING);
	esc_set_all_nets_mode(ORIGINAL);
	// esc_set_pwr(CONNECTED);
	esc_set_pwr(FLOATING); //TODO


	adc_measurement_t measurements[NUM_VOLTAGE_CHANNELS] = {0};
	adc_take_measurements(measurements, VOLTAGE);
	bool any_failures = config_evaluate_voltages(measurements);
	rpi_send_debug_info((uint8_t*)measurements, sizeof(measurements));
	if (any_failures) {
		lcd_clear_screen();
		lcd_printf(LCD_LINE_1, "Voltage Fault");
		lcd_print_failed_nets(measurements, NUM_VOLTAGE_CHANNELS);
	} else {
		lcd_clear_screen();
		lcd_printf(LCD_LINE_1, "All Tests Pass");
		lcd_printf(LCD_LINE_2, "Remove ESC");
	}
	while (esc_is_connected()) {
		lcd_print_failed_nets(measurements, NUM_RESISTANCE_CHANNELS);
		HAL_Delay(1);
	}
	return;

}

/*
	Print names of failed nets to LCD line 2
 */
void lcd_print_failed_nets(adc_measurement_t* measurements, int num_measurements) {
	char failed_nets_buf[64];
	failed_nets_buf[0] = '\0';
	for (int i = 0; i < num_measurements; i++) {
		if (measurements[i].result == FAIL) {
			if (failed_nets_buf[0] != '\0') {
				strcat(failed_nets_buf, ",");
			}
			strcat(failed_nets_buf, measurements[i].name);
		}
	}
	lcd_printf(LCD_LINE_2, "%s", failed_nets_buf);
}

void debug_lcd_print_measurements(adc_measurement_t* measurements) {
	lcd_printf(LCD_LINE_1, "%s:%.3fK", measurements[2].name, measurements[2].measurement/1000);
	lcd_printf(LCD_LINE_2, "%s:%.3fK", measurements[6].name, measurements[6].measurement/1000);
}
