#include "stm32_spi_link.h"
#include "meas_config.h"
#include "main.h"

static uint8_t spi_tx_buf[BUFFER_SIZE];
static uint8_t spi_rx_buf[BUFFER_SIZE];
static uint8_t rx_copy_buffer[BUFFER_SIZE];

static SPI_HandleTypeDef *h_spi;
volatile bool* h_packet_recieved;

static void spi_int_assert(void) {
    HAL_GPIO_WritePin(SPI_INT_GPIO_Port, SPI_INT_Pin, GPIO_PIN_SET);
}

static void spi_int_deassert(void) {
    HAL_GPIO_WritePin(SPI_INT_GPIO_Port, SPI_INT_Pin, GPIO_PIN_RESET);
}

void start_listening() {
	while (HAL_SPI_TransmitReceive_DMA(h_spi, spi_tx_buf, spi_rx_buf, BUFFER_SIZE) != HAL_OK) {}
}

void stop_listening() {
	HAL_SPI_Abort(h_spi);
}

void link_init(SPI_HandleTypeDef *spi, bool* packet_recieved) {
    h_spi = spi;
    h_packet_recieved = packet_recieved;
    spi_int_deassert();
    memset(spi_tx_buf, 0x80, BUFFER_SIZE);
    // Start listening for a packet from the Pi.
    start_listening();
}



/**
 * @brief This function contains the application logic to process a fully received packet.
 */
void process_packet() {
	rx_commands_t command = rx_copy_buffer[0];
    uint16_t payload_len = (rx_copy_buffer[1] << 8) | rx_copy_buffer[2];

    // Point to the payload, which starts after the 3-byte header
    const uint8_t* payload = &rx_copy_buffer[3];

    switch (command) {
        case SET_CONFIG:
        	process_config((MeasConfig_t*)payload);
            break;

        case SEND_TEXT:
            process_text((char*)payload, payload_len);
            break;

        default:
            // Handle unknown command
            break;
    }
}

void process_text(char* text, uint16_t len) {
	printf("Received Text: %.*s\r\n", len, text);

    if(strncmp(text, "ping", len) == 0) {
        const char* response = "pong";
        send_packet_to_pi(LOG_MESSAGE, (const uint8_t*)response, strlen(response));
    }
}

void process_config(MeasConfig_t* received_config) {
	printf("Received Config Data with\r\n");
	printf("  dac1_voltage: %f\r\n", received_config->dac1_voltage);
	printf("  threshold1: %f\r\n", received_config->threshold1);
	printf("  dac2_voltage: %f\r\n", received_config->dac2_voltage);
	printf("  threshold2: %f\r\n", received_config->threshold2);
}

void send_packet_to_pi(tx_commands_t command, const uint8_t* payload, uint16_t length) {
    if ((length + 3) > BUFFER_SIZE) {
       printf("Attempted to send too big a packet\r\n");
       Error_Handler();
       return;
    }

    //Build the packet header
    spi_tx_buf[0] = command;
    spi_tx_buf[1] = (length >> 8) & 0xFF;
    spi_tx_buf[2] = length & 0xFF;

    //Copy the payload
    memcpy(&spi_tx_buf[3], payload, length);

    //Signal the Pi that data is ready
    spi_int_assert();
}

// --- STM32 HAL CALLBACKS ---

/**
 * @brief Callback for when a reception from the Pi (Master) is complete.
 * @note This is triggered when the Pi raises the Chip Select (CS) line.
 */
void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *spi) {
	spi_int_deassert();
	*h_packet_recieved = true;
	memcpy(rx_copy_buffer, spi_rx_buf, BUFFER_SIZE);

}

/**
 * @brief  SPI error callback.
 * @param  hspi: SPI handle
 * @note   This function is executed when a communication error is detected.
 */
void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi) {
	//uint32_t error_code = HAL_SPI_GetError(hspi);
	HAL_SPI_Abort(hspi); // Abort current operations
	start_listening();
}
