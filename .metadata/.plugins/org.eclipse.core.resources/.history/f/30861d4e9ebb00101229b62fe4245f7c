#include "lcd.h"

static uint8_t _showfunction;
static uint8_t _showcontrol;
static uint8_t _showmode;
static uint8_t _currline;

static I2C_HandleTypeDef* i2c;


// HELPERS

static void command(uint8_t cmd)
{
    uint8_t val[2] = {0x80,cmd};
    HAL_I2C_Master_Transmit(_hi2c, LCD_ADDRESS, val, 2, 1000);
}

static void display()
{
    command(LCD_DISPLAYCONTROL | _showcontrol);
    HAL_Delay(2);
}


static void setReg(uint8_t reg,uint8_t data)
{
    uint8_t val[2] = {reg,data};
    HAL_I2C_Master_Transmit(_hi2c, RGB_ADDRESS, val, 2, 1000);
}


static void write_char(uint8_t data)
{
    uint8_t val[2] = {0x40,data};
    HAL_I2C_Master_Transmit(_hi2c, LCD_ADDRESS, val, 2, 1000);
}

static void send_string(const char *str)
{
	uint8_t i;
	for(i = 0; str[i] != '\0';i++)
		write_char(str[i]);
}

static void setCursor(uint8_t col, uint8_t row)
{
    if(row == 0)
    {
        col |= 0x80;
    }
    else
    {
        col |= 0xc0;
    }
    command(col);
}

void LCD_Init(I2C_HandleTypeDef* hi2c)
{
	i2c = hi2c;

    _showfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
    _showfunction |= LCD_2LINE;
    _currline = 0;


    ///< SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
    ///< according to datasheet, we need at least 40ms after power rises above 2.7V
    ///< before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50
    HAL_Delay(50);


    ///< this is according to the hitachi HD44780 datasheet
    ///< page 45 figure 23

    ///< Send function set command sequence
    command(LCD_FUNCTIONSET | _showfunction);
    HAL_Delay(10);  // wait more than 4.1ms

	///< second try
    command(LCD_FUNCTIONSET | _showfunction);
    HAL_Delay(10);

    ///< third go
    command(LCD_FUNCTIONSET | _showfunction);

    //command(LCD_FUNCTIONSET | _showfunction);


    ///< turn the display on with no cursor or blinking default
    _showcontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
    display();

    ///< clear it off
    LCD_Clear();

    ///< Initialize to default text direction (for romance languages)
    _showmode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
    ///< set the entry mode
    command(LCD_ENTRYMODESET | _showmode);


    ///< backlight init
    setReg(REG_MODE1, 0);
    HAL_Delay(2);
    ///< set LEDs controllable by both PWM and GRPPWM registers
    setReg(REG_OUTPUT, 0xFF);
    HAL_Delay(2);
    ///< set MODE2 values
    ///< 0010 0000 -> 0x20  (DMBLNK to 1, ie blinky mode)
    setReg(REG_MODE2, 0x20);

    LCD_Set_RGB(255,255,255);

}

void LCD_Clear()
{
    command(LCD_CLEARDISPLAY);
    HAL_Delay(2);
}

void LCD_Set_RGB(uint8_t r,uint8_t g,uint8_t b)
{
    setReg(REG_RED,r);
    setReg(REG_GREEN,g);
    setReg(REG_BLUE,b);
}

void LCD_Send_String(uint8_t col, uint8_t row, const char *str) {

	setCursor(col, row);
	send_string(str);
}
