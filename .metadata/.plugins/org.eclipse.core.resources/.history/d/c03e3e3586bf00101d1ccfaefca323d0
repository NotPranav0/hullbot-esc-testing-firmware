#include "config.h"

static config_t config;

const float P1V2_R_THRESHOLD_DEFAULT = 0;
const float P1V8_R_THRESHOLD_DEFAULT = 0;
const float P3V3A_R_THRESHOLD_DEFAULT = 0;
const float P3V3IO_R_THRESHOLD_DEFAULT = 0;
const float P5V_R_THRESHOLD_DEFAULT = 0;
const float P10V_R_THRESHOLD_DEFAULT = 0;
const float PVMAIN_R_THRESHOLD_DEFAULT = 0;
const float SWD_R_THRESHOLD_DEFAULT = 0;
const float CAN_R_THRESHOLD_DEFAULT = 0;


const float P1V2_V_EXPECTED_DEFAULT = 0;
const float P1V8_V_EXPECTED_DEFAULT = 0;
const float P3V3A_V_EXPECTED_DEFAULT = 0;
const float P3V3IO_V_EXPECTED_DEFAULT = 0;
const float P5V_V_EXPECTED_DEFAULT = 0;
const float P10V_V_EXPECTED_DEFAULT = 0;
const float PVMAIN_V_EXPECTED_DEFAULT = 0;

const float P1V2_V_TOLERANCE_DEFAULT = 0;
const float P1V8_V_TOLERANCE_DEFAULT = 0;
const float P3V3A_V_TOLERANCE_DEFAULT = 0;
const float P3V3IO_V_TOLERANCE_DEFAULT = 0;
const float P5V_V_TOLERANCE_DEFAULT = 0;
const float P10V_V_TOLERANCE_DEFAULT = 0;
const float PVMAIN_V_TOLERANCE_DEFAULT = 0;

config_resistance_thresholds_t res_thresholds[] = {
    {.name = "P1V2", .threshold = P1V2_R_THRESHOLD_DEFAULT},
    {.name = "P1V8", .threshold = P1V8_R_THRESHOLD_DEFAULT},
    {.name = "P3V3_A", .threshold = P3V3A_R_THRESHOLD_DEFAULT},
    {.name = "P3V3_IO", .threshold = P3V3IO_R_THRESHOLD_DEFAULT},
    {.name = "P5V", .threshold = P5V_R_THRESHOLD_DEFAULT},
    {.name = "P10V", .threshold = P10V_R_THRESHOLD_DEFAULT},
    {.name = "PVMAIN", .threshold = PVMAIN_R_THRESHOLD_DEFAULT},
    {.name = "SWD", .threshold = SWD_R_THRESHOLD_DEFAULT},
    {.name = "CAN", .threshold = CAN_R_THRESHOLD_DEFAULT}
};

config_voltage_tolerances_t voltage_tolerances[] = {
    {.name = "P1V2", .expected = P1V2_V_EXPECTED_DEFAULT, .tolerance = P1V2_V_TOLERANCE_DEFAULT},
    {.name = "P1V8", .expected = P1V8_V_EXPECTED_DEFAULT, .tolerance = P1V8_V_TOLERANCE_DEFAULT},
    {.name = "P3V3_A", .expected = P3V3A_V_EXPECTED_DEFAULT, .tolerance = P3V3A_V_TOLERANCE_DEFAULT},
    {.name = "P3V3_IO", .expected = P3V3IO_V_EXPECTED_DEFAULT, .tolerance = P3V3IO_V_TOLERANCE_DEFAULT},
    {.name = "P5V", .expected = P5V_V_EXPECTED_DEFAULT, .tolerance = P5V_V_TOLERANCE_DEFAULT},
    {.name = "P10V", .expected = P10V_V_EXPECTED_DEFAULT, .tolerance = P10V_V_TOLERANCE_DEFAULT},
    {.name = "PVMAIN", .expected = PVMAIN_V_EXPECTED_DEFAULT, .tolerance = PVMAIN_V_TOLERANCE_DEFAULT}
};


static adc_result_t config_evaluate_resistance_threshold(float measurement, float threshold);
static adc_result_t config_evaluate_voltage_tolerance(float measurement, float expected, float tolerance);

// Public

config_t* config_init() {
	memcpy(config.resistance_thresholds, res_thresholds, sizeof(res_thresholds));
	memcpy(config.voltage_tolerances, voltage_tolerances, sizeof(voltage_tolerances));
	return &config;
}

bool config_evaluate_resistances(adc_measurement_t* measurements) {
	uint32_t results = 0;
	for (int i = 0; i < NUM_RESISTANCE_CHANNELS; i++) {
		measurements[i].result = config_evaluate_resistance_threshold(measurements[i].measurement, config.resistance_thresholds[i].threshold);
		results |= (measurements[i].result << i);
	}

	// results = 0 means all PASS
	// return true if any failures
	return (results != 0);
}
	
bool config_evaluate_voltages(adc_measurement_t* measurements) {
	uint32_t results = 0;
	for (int i = 0; i < NUM_VOLTAGE_CHANNELS; i++) {
		measurements[i].result = config_evaluate_voltage_tolerance(measurements[i].measurement, config.voltage_tolerances[i].expected, config.voltage_tolerances[i].tolerance);
		results |= (measurements[i].result << i);
	}

	return (results != 0);
}

// Private

static adc_result_t config_evaluate_resistance_threshold(float measurement, float threshold) {
	if (measurement >= threshold) {
		return PASS;
	} else {
		return FAIL;
	}
}

static adc_result_t config_evaluate_voltage_tolerance(float measurement, float expected, float tolerance) {
	if (measurement >= (expected - tolerance) && measurement <= (expected + tolerance)) {
		return PASS;
	} else {
		return FAIL;
	}
}

